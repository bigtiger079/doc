# REVERSE

## 汇编笔记

每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出3种总线的宽度标志了这个CPU的不同方面的性能：  

* 地址总线的宽度决定了CPU的寻址能力；
* 数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量；
* 控制总线的宽度决定了CPU对系统中其他器件的控制能力。


**内存地址空间(概述)**  
什么是内存地址空间呢？举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。

### 寄存器

8086CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。



**字在寄存器中的存储**

出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据：
  
* 字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。  
* 字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。


**数据段:**

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。

- 我们可以用一个段存放数据，将它定义为“数据段”；

- 我们可以用一个段存放代码，将它定义为“代码段”；

- 我们可以用一个段当作栈，将它定义为“栈段”；

我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：

- 对于数据段，将它的段地址放在 DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据段来访问；

- 对于代码段，将它的段地址放在 CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；

- 对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地置放在 SP 中，这样CPU在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用

####  [bx]和内存单元

[bx]是什么呢？

和[0]有些类似，[0]表示内存单元，它的偏移地址是0。  

我们要完整地描述一个内存单元，需要两种信息：

（1）内存单元的地址；  

（2）内存单元的长度（类型

我们用[0]表示一个内存单元时，0 表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出  

所以，按照这样的原理，我们对如下指令可以这样理解：

- Mov ax,［0］：表示将一个内存单元的内容送入ax寄存器。其中内存单元的长度为2字节，偏移地址为0,段地址在ds中。

- Mov al,［0］：表示将一个内存单元的内容送入al寄存器。其中内存单元的长度为1字节，偏移地址为0,段地址在ds中。

- Mov ax,[bx]:表示将一个内存单元的内容送入ax寄存器。其中内存单元的长度为2字节，偏移地址在bx中,段地址在ds中。


> bx、si、di、bp  
> 这4个寄存器（bx、bp、si、di）可以用在“[…]” 中来进行内存单元的寻址  
> 只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中




## 脱壳


### 方法汇总


脱壳就是将已经加壳的程序从壳中剥离出来。既然能给程序进行加壳，那也会有相应的脱壳方法。尽管理在有些壳很难脱掉，但是脱壳技术也在不断的进步，而且在不断竞争中发展状大。  
　　1、OEP  
　　OPE的意思就像它的名字一样容易理解。OEP就是原程序的入口点，也就是真正的入口点。  
　　当被加壳的程序运行后，首先运行的是壳程序，壳程序会将原程序还原到内存中并将控制权返还。OEP总会在这期间被脱壳者找到。只要找到这个OEP，就可以将原程序从内存中dump出来，而后针对dump出的程序进行处理，最终得到原程序。  
　　一般来说，脱壳就是要找程序的OEP，得到这个OEP，脱壳就完成一半了，剩下的就是修复工作了。  
　　2、脱壳的用处  
　　脱壳用处很大，可以破除壳程序对程序的保护。从而使我们更接近程序代码，了解这个程序。而对于免杀制作者来说，脱壳的用处也很大，有些木马生成的服务端默认就被加壳。壳把这个木马服务端保护起来了，这或多或少对我们的免杀造也了阻碍。所以免杀制作者往往先将木马服务端的壳脱掉，而后再按照平时免杀的方法对木马服务端进行免杀处理。由此可见，基础的脱壳技能是免杀技术爱好者的技能。  



####     一、单步跟踪法

　　脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法就是利用OD的单条指令执行功能，从壳的入口一直执行到OEP，最终通过这个OEP将原程序dump出来。然当，在单步跟踪的时候需要跳过一些不能执行到的指令。  
　　使用单步跟踪法追踪OEP的常见步骤：  
　　1、用OD载入待脱壳文件，如果出现压缩提示，选择“不分析代码”； 
　　2、向下单步跟踪，实现向下的跳转；  
　　3、遇到程序往上跳转的时候（包括循环），在回跳的下一句代码上单击并按键盘上的“F4”键跳过回跳指令；  
　　4、OD中的绿色线条表示跳转没有实理，不必理会，红色线条表示跳转已经实现；  
　　5、如果刚载入程序的时候，在附近有一个CALL指令，那么就要按键盘上的“F7”键跟进这个CALL内，不然程序很容易运行起来； 
　　6、在跟踪的时候，如果执行某个CALL指令后就运行，一定要按键盘上的“F7”键进入这个CALL之内再单步跟踪；  
　　7、遇到在popad指令下的远转移指令时，要格处注意，因为这个远转移指令的目的地很可能就是OEP。  

####　　二、ESP定律法

　　ESP定律法是脱壳的利器，是国外友人发现的。有了ESP定律，可以方便我们脱掉大多数的压缩壳。可谓是本世纪破解界中最伟大的发现之一。这里只简单的看一下狭义ESP定律的原理。  
　　使用ESP定律追踪OEP的常见步骤：  
　　1、将待脱壳程序载入到OD中，开始就按键盘上的“F8”键单步跟踪一步，这时如果看到OD右边的寄存器窗口中的ESP寄存器的值有没有变为红色，如果发现ESP寄存器的值变为红色，执行第2步；  
　　2、在OD的命令行窗口中执行命令hrXXXXXXXX,xxxxxxxx就是变为红色的ESP寄存器的值，在输入命令之后，一定不要忘记按键盘上的回车键；  
　　3、按键盘上的“F9”键让程序运行起来；  
　　4、使用单步跟踪的方法跟踪到OEP即可。  

####　　三、二次断点法

　　二次断点是有技巧的下两个断点，在两个断点之后就可以很轻松的找到OEP。  
　　使用二次断点法追踪OEP的常见步骤：  
　　1、将待脱壳程序载入到OD中，单击OD的“选项”菜单下的“调试设置”命令，在弹出的“调试选项”对话框中切换到“异常”选项卡，勾选该选项卡下的所有复选框，也就是忽略所有异常；  
　　2、按键盘上的“ALT+M”组合键打开OD的内存窗口；  
　　3、在OD的内存窗口中找到“.rsrc”区段，单击该区段后按键盘上的“F2”键在该区段上下一断点；  
　　4、按“Shift+F9”让程序运行到断点心处，而后再次打开OD的内存窗口，这次在“.rsrc”区段上面的“.code”区段（有的时候就是“.text”）上下一个断点；  
　　5、按“shift+F9”让程序运行到第二次下的断点处，然后单步跟踪既可以来到OEP。  

####　　四、末次异常法

　　在脱壳方法中，末次异常法又被称为最后一次异常法，这是最基础的脱壳技术之一。末次异常法脱壳很是简单，但就是这简单的脱壳方法可以挑掉曾经风靡一时的强壳。  
　　使用末次异常法追踪OEP的常见步骤：  
　　1、将待脱壳程序载入到OD中，单击OD的“选项”菜单，在弹出的菜单中单击“调试设置”命令，在随后弹出的“调试选项”对话框中切换到“异常”选项卡，清除该选项卡下所有复选框，也就是不忽略任何异常；  
　　2、连续按键盘上的“Shift+F9”组合键让程序运行起来，记录按键的次数X；  
　　3、回到OD中，按键盘上的“Ctrl+F2”组合键重新载入程序，按X-1次“Shift+F9”组合键；  
　　4、在OD右下角窗口中找到“SE句柄”或是“SE处理程序”，记录此处的内存地址；  
　　5、在OD的反汇编窗口中跟随到上一步记录下的内存地址，并在此内存地址处下一个断点；  
　　6、按键盘上的“Shift+F9”组合键让程序运行到上一步下的断点处，按键盘上的“F2”键取消此处的断点；  
　　7、使用单步跟踪法追踪到OEP。  

####　　五、模拟跟踪法

　　在这章中讲到的众多脱壳方法中，我们首先讲了单步跟踪法脱壳，因为单步跟踪脱壳法是脱壳技术中最基础的方法，在后面其它的一些脱壳方法中总会或多或少的配合单步跟踪法才能顺利完成脱壳工作。便是始终是一次次的按“F8”键来单步跟踪程序，偶尔遇到回跳就跳过执行，这样机械性的操作很是烦人，那么能不能让机器来代替人力，让工具帮我们单步跟踪呢？答案是肯定的，这也就是这节讲的内容——模拟跟踪法。模拟脱壳法就是模拟单步跟踪来进行查找OEP。  
　　模拟跟踪法的常见步骤：  
　　1、将待脱壳程序载入OD中，先简单的跟踪一下程序，看看有没有SEH暗桩；  
　　2、按键盘上的“ALT+F9”打开OD的内存窗口，找到“SFX，输入表，资源”的行，并记录此行的内存地址；  
　　3、在OD的命令行窗口执行命令“tc   eip<上一步中记录下的地址”，命令执行后就会跟踪到OEP。  

####　　六、SFX自动脱壳法

　　在上一节，我们使用模拟跟踪法代替手动单步跟踪法进行脱壳。在OD中，不但可以利用模拟跟踪来代替单步跟踪进行脱壳，从而节省劳动力，还有一种SFX自动脱壳的方法也可以节省劳动力，并能快速有效的将程序的壳脱掉。  
　　使用SFX自动脱壳法脱壳的常见步骤：  
　　1、将OD设置为忽略所有异常；  
　　2、在OD的“调试选项”对话框的“SFX”选项卡中选择“字节模式跟踪实际入口”选项并确定；  
　　3、将待脱壳程序载入OD，待程序载入完成后，会直接停在OEP处。  

####　　七、出口标志法

　　前面几个脱壳方法中有一个共同点，就是在单步跟踪到popad指令后面不远处的jmp指令的时候，就可以大胆的判断这个jmp指令的目的地址就是OEP。原因很简单，popad指令用于将壳运行之前保存的环境恢复，使原程序能正常运行。有些壳的popad指令很少，我们就可以查看被这种壳加壳的程序的所有popad指令，找到后面存在jmp指令的popad指令，然后来到其后的jmp指令的目的地址，这很可能就是OEP，然后就可以进行dump脱壳了。  
　　使用出口标志法脱壳的常见步骤：  
　　1、将待脱壳程序载入OD中，在OD的反汇编客人口中单击鼠标右键，在弹出的右键菜单中单击“查找”→“所有命令”，在弹出的输入框中输入“popad”并按“查找”按钮；  
　　2、逐一尝试跟踪查找到的所有“popad”指令，最终达到程序的OEP。  


####　　八、使用脱壳脚本辅助脱壳

　　在脱壳的时候，使用模拟跟踪法可以让OD代替我们单步跟踪程序直到OEP，这样大大提高了脱壳的效率。但是模拟跟踪法并不能跟踪到一些较强的壳的OEP，这时我们可以使用高手们写的脱壳脚本来帮助我们完成脱壳工作，使用脱壳脚本来脱壳要比手动跟踪方便得多。脱壳脚本就是高手们为了方便自己或他人脱壳，把自己手动脱壳的步骤记录下来，保存的一个文本文档。虽然脱壳脚本是一个文本文档，可以使用记事本将其打开，但是轻易不要用这种方式修改脱壳脚本，因为直接修改脱壳脚本，很可能造成脱壳脚本不能正确完成对应的脱壳工作。  


####　　九、使用脱壳工具脱壳

　　脱壳工具很多，这里只介绍最为实用的全自动脱壳机——超级巡警脱壳工具。 
　　超级巡警脱壳工具的工作方法：  
　　超级巡警脱壳工具会自动侦测待脱壳程序所加的壳头，从而判断出带脱壳程序是用哪种壳程序加壳的。如果超级巡警脱壳工具支持对该壳的脱壳，就可以很方便的将程序的壳脱掉；如果不支持对该壳的脱壳，则会给我们一个简单明了的提示。  
如恒大所说新手尽量使用脱壳机脱壳。  




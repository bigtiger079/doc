# PWN

## 基础知识

函数状态主要涉及三个寄存器－－esp，ebp，eip：   

* esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。  
* ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。  
* eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令

### 函数调用过程中栈的状态变化

1. 首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。  

2. 然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。  

3. 再将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。  

4. 再之后是将被调用函数（callee）的局部变量等数据压入栈内。  

在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。

## 堆栈溢出攻击技术

* 修改返回地址，让其指向溢出数据中的一段指令（shellcode）
* 修改返回地址，让其指向内存中已有的某个函数（return2libc）
* 修改返回地址，让其指向内存中已有的一段指令（ROP）
* 修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）

### 1. shellcode

*－－修改返回地址，让其指向溢出数据中的一段指令*

要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。 攻击指令一般都是用来打开 shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为“shellcode”。 shellcode 可以用汇编语言来写再转成对应的机器码，也可以上网搜索直接复制粘贴。

溢出数据的组成:  
**payload** : padding1 + address of shellcode + padding2 + shellcode

padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式。  
返回地址之前的填充数据（padding1）的长度我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。
